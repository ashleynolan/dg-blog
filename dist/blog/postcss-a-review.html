<!doctype html>

<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">


		<title>PostCSS – Sass Killer or Preprocessing Pretender? - AshleyNolan.co.uk - Blog and Portfolio for Ashley Nolan</title>
		<meta name="description" content="PostCSS – Sass Killer or Preprocessing Pretender? - AshleyNolan.co.uk - Blog and Portfolio for Ashley Nolan">


		<link href="https://ashleynolan.co.uk/feed.xml" rel="alternate" type="application/rss+xml" title="Front-end development Blog and Portfolio for Ashley Nolan" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="shortcut icon" href="/assets/img/icons/favicon.ico">
		<link rel="apple-touch-icon" href="/assets/img/icons/apple_touch_icon.png">


		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@AshNolan_" />
		<meta name="twitter:title" content="PostCSS – Sass Killer or Preprocessing Pretender?" />
		<meta name="twitter:description" content="I take a look at a front-end tool that’s been gathering a fair bit of attention as of late." />
		<meta name="twitter:image" content="http://www.ashleynolan.co.uk/assets/img/icons/logo-tcard.png" />


		<!-- CSS -->
		<link rel="stylesheet" href="/assets/css/kickoff.min.css">

		<!-- Fonts – non blocking -->
		<link href='https://fonts.googleapis.com/css?family=Muli:300,400' rel='stylesheet' type='text/css'>
		<script>
			(function(d) {
				var config = {
					kitId: 'xxf1gwm',
					scriptTimeout: 3000
				},
				h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='//use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
			})(document);
		</script>


		<!-- Require include for JS -->
		<script src="/assets/js/components/requirejs/require.js" data-main="/assets/js/dist/app.min" async></script>

	</head>
	<body>


	<div class="container">
		<header class="page-header">
	<div id="page-logo" class="logo">
		<span>Front-end development Blog and Portfolio for Ashley Nolan – Senior UI Engineer at JUST EAT</span>
		<a href="/" class="logo-link">
			<svg class="logo-dg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" width="234px" height="244.082px" viewBox="0 0 234 244.082" enable-background="new 0 0 234 244.082" xml:space="preserve"><g><g><path clip-rule="evenodd" d="M131.012 68.469c-20.294 5.482-35.874 16.834-38.992 43.7 C68.354 94.6 98.1 47 131 68.469z"/><path clip-rule="evenodd" d="M161.475 59.629c12.752-4.078 0 17.3 8.7 17.3 c-9.173 6.152-19.891-10.842-34.687-8.67C140.716 62 158 67.7 161.5 59.629z"/><path clip-rule="evenodd" d="M76.527 92.79c1.633 4.2 3.7 8.7 6.2 12.5 c2.608 3.9 6.1 7.4 11.2 7.159c-12.189 3.479-23.696 8.262-32.159 18.087c-8.423 9.783-13.461 22.025-16.949 34.3 c-9.061-6.983-14.794 8.593-17.451 14.883c-2.349 5.562-4.978 21.5 6.6 13.891c4.448-2.942 6.602-8.919 12.695-9.151 c-2.969 8.274-6.594 15.987-16.213 17.148c-6.54 0.793-13.054-1.491-18.517-4.962c-2.951-1.873-12.159-8.419-11.935-12.306 c0.512-8.898 10.552-1.189 11.557-8.245c0.624-4.385 0.271-8.806 1.136-13.17c0.908-4.596 2.435-9 2.911-13.689 c3.605 0.3 1.2 6.6 3.9 7.8c10.032-3.507 16.879-11.737 21.362-21.088c2.364-4.937 4.222-10.091 5.968-15.275 c1.456-4.331 1.404-9.623 4.134-13.46c2.841-3.982 7.878-4.951 12.226-6.405C68.082 99.2 72.8 96.4 76.5 92.79z"/><path clip-rule="evenodd" d="M99.255 119.897c9.81 1.9 10.7 5.8 14.9 10.4 c-6.827 6.479-9.902 22.673-5.977 28.901C95.175 156.3 96.8 135.4 99.3 119.897z"/><path clip-rule="evenodd" d="M121.206 137.488c4.894 3 4.4 9.1 6.3 13.9 c-4.936 6.197-10.997 10.411-12.33 22.914C112.079 163.8 115.3 148.9 121.2 137.488z"/><path clip-rule="evenodd" d="M121.605 0c-8.263 15.3 13.1 46.006-1.949 62.4 c-4.596 0.042-5.744-3.36-11.703-1.95C127.689 49.1 102.9 13.8 121.6 0z"/><path clip-rule="evenodd" d="M61.149 5.85c0.1 1.5 1.8 3.1 1.8 5.2 c0.022 2.82-1.059 5.84-1.923 8.48c-2.215 6.783-5.087 13.333-7.233 20.14c-2.608 8.272-5.14 16.396-3.13 25.2 c1.524 6.7 5.9 11.6 11.8 5.692c10.53-10.562 13.605-29.733 18.273-43.378c2.764-8.071 6.217-16.493 11.633-23.199 c-2.654 3.288-2.392 9.859-3.548 13.882c-1.621 5.636-4.147 11.421-3.27 17.417c1.068 7.3 7 7.1 12.4 4.2 c-2.96 1.573-4.405 7.437-6.289 9.995c-2.853 3.876-5.893 7.625-8.38 11.76c-5.954 9.899-8.374 20.95-6.517 32.4 c-7.399 4.952-11.64 13.063-25.353 11.702c-13.303 10.749-23.374 24.729-27.301 44.855c-8.519-20.394 8.5-46.808 19.502-60.457 c-2.158-18.473-6.726-26.699-3.901-40.953C43.038 31.9 62.5 25.6 61.1 5.85z"/><path clip-rule="evenodd" d="M174.777 89.915c4.768-4.601 12.5 8.9 24.8 5 c-3.096 9.324-6.504 18.33-7.452 29.802C186.195 113.3 185.1 96.9 174.8 89.915z"/><path clip-rule="evenodd" d="M96.251 171.615c-2.344 13.276-7.652 40.438-19.501 50.7 c-12.253 1.199-12.991-9.11-23.404-9.753c1.273-5.876 7.661-6.643 9.752-11.697c2.327-15.337-1.888-48.907-13.054-56.462 c6.053-10.196 13.143-22.067 26.409-25.055c-1.406 8.7 9.6 20.2 10 26.911c1.374 19.759-16.337 38.35-11.705 64.4 C85.648 209.1 89.4 183.7 96.3 171.615z"/><path clip-rule="evenodd" d="M192.558 129.948c5.485 9.1 6.5 22.7 14.6 29.3 c-5.582 5.123-22.907 35.464-17.555 23.41C189.939 164.4 194.5 150.4 192.6 129.948z"/></g><path clip-rule="evenodd" d="M99.087 116.263c0 0 10.719-54.502 47.354-40.207 c0 0 54.2 11.5 32.2 97.39C162.524 236 234 236 234 235.987s-109.006 42.894-101.854-68.795 C132.147 167.2 133.9 122.5 99.1 116.263z"/></g></svg>
			<img src="/assets/img/dg_logo.png" class="logo-dg" alt="Ashley Nolan">
		</a>
	</div>

	<!-- main navigation links -->
	<section id="nav-strip" class="nav-strip">
		<!-- Global Navigation links -->
<nav id="page-nav" class="nav-global">
	<ul>
		<li class="nav-global-item"><a href="/blog/" data-hover="Blog">Blog</a><span class="navArrow"></span></li><!--
		--><li class="nav-global-item"><a href="/work" data-hover="Work">Work</a><span class="navArrow"></span></li><!--
		--><li class="nav-global-item last "><a href="/about" data-hover="About">About</a><span class="navArrow"></span></li>
	</ul>
</nav>
	</section>
</header>


		<section class="content post">
			<h1>PostCSS – Sass Killer or Preprocessing Pretender?</h1>

			

<p><a href="https://github.com/postcss/postcss">PostCSS</a> first came onto my radar back in February when I read Ben Frain’s excellent article – <a href="http://benfrain.com/breaking-up-with-sass-postcss/">Breaking up with Sass: it’s not you, it’s me</a>.  I was extremely happy with my workflow at the time – using Sass for all of my preprocessing needs – but it piqued my interest in PostCSS enough to make sure that I filed it away in the &#39;must investigate later&#39; part of my head (one that seems to be constantly overflowing).</p>
<p>Upon joining <a href="/blog/a-new-challenge">JUST EAT back in May</a>, my first task has been to review and potentially redefine our front-end processes going forward.  As part of this review, I thought it was time to take a deeper look into PostCSS and what it has to offer.</p>
<p>So is PostCSS the future of preprocessing?  Here’s my thoughts on the subject.</p>
<hr>
<p><strong>N.b.</strong> PostCSS has been mooted previously as a postprocessor.  However, like Chris Coyier concluded in <a href="https://css-tricks.com/the-trouble-with-preprocessing-based-on-future-specs/">his recent article on the topic</a>, I will be referring to PostCSS as a <strong>preprocessor</strong> rather than as a postprocessor, as it processes custom code into CSS via a build step, which to me is still preprocessing – i.e. processing that happens before it is compiled into the CSS that your browser will then evaluate.</p>
<p>I will also refer to Sass by way of a comparison to PostCSS, as that’s simply what I currently use.  See these references as also being applicable to similar tools such as Less and Stylus.</p>
<hr>
<h2 id="what-is-postcss">What is PostCSS</h2>
<p>For anyone unfamiliar with <a href="https://github.com/postcss/postcss">PostCSS</a>, it’s a tool that helps to provide feature extensions when writing CSS, not wildly dis-similar to preprocessors such as <a href="http://sass-lang.com/">Sass</a>, <a href="http://lesscss.org/">Less</a> and <a href="https://learnboost.github.io/stylus/">Stylus</a>.  It does however have some very distinct differences to these other tools.</p>
<p>A traditional preprocessor like Sass gives you a whole bunch of functionality all bundled into one tool, irrespective of whether you need or will use all of those features.</p>
<p>On the flip side, PostCSS is a blank slate; you can add as many or as few features to your process as you require.</p>
<p>These features come in the shape of <strong>PostCSS plugins</strong>. Think of these like using LEGO, where each piece is a different feature that can transform your CSS in some way.  PostCSS lets you stick together these pieces so that you can build up your own feature set, adding and removing plugins as and when you need them.</p>
<p>So for example, if you only want the ability to use CSS Variables and Nesting when writing your CSS, you can add a plugin for each of these features to your PostCSS build to start using them.</p>
<p>Another example is <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a>, the popular prefix-management tool.  This is actually a PostCSS plugin that has been made more accessible through the creation of <a href="https://github.com/ndmitry/grunt-autoprefixer">Grunt</a> and <a href="https://github.com/sindresorhus/gulp-autoprefixer">Gulp</a> packages.  These packages have now been superseded by <a href="https://github.com/nDmitry/grunt-postcss">grunt-postcss</a> and <a href="https://github.com/postcss/gulp-postcss">gulp-postcss</a>, through which you can use Autoprefixer in your PostCSS build.</p>
<h2 id="why-is-this-useful-">Why is this useful?</h2>
<p>Good question!  So being able to add and remove features in this way is useful for a couple of reasons:</p>
<p><strong>I. Because developers can do stupid things sometimes</strong></p>
<p>I love using Sass.  It’s a hugely powerful tool that gives me features that I’d genuinely find it hard to live without.</p>
<p>The problem is, not everyone uses it responsibly.</p>
<p>I’ve <a href="/blog/writing-css-and-sass-that-doesnt-suck">written about this in the past</a>, but I’ve seen developers do some really dumb things when using Sass that they (probably) wouldn’t do when writing vanilla CSS.  The <code>@extends</code> feature in particular can cause a whole world of pain when used improperly, but even something as simple as nesting in some peoples hands can reap horrible consequences.</p>
<p>For example, at JUST EAT, anyone across a whole group of teams can edit our projects CSS files – front-end devs, .NET devs, anyone.  This is great, but not everyone is at the same level when it comes to CSS best practices and standards.  We have code reviews to help mitigate this, but by throwing Sass into the mix, it opens up a whole bunch of extra functionality that some of our team may not fully understand how to use.  The possibility of a developer writing some Sass that produces a whole bunch of unnecessary CSS when compiled therefore increases.</p>
<p>Being able to limit the features that are available when writing CSS on your project could therefore be incredibly useful.</p>
<p><strong>II. Extensibility</strong></p>
<p>If you wanted to extend the functionality of a preprocessor like Sass, it’s not simple.  The codebase for projects like this are quite large and you’d have to understand what’s going on under the hood before trying to contribute to that project.</p>
<p>Even once you’ve written your extension and made a pull request, there’s no guarantee that your feature will be accepted and implemented into the codebase, as the maintainers might not want that functionality as part of the base feature set.</p>
<p>As PostCSS is made up of plugins, extending it is much easier.  You can simply write your own plugin to transform your CSS in the way you require and add it into your PostCSS compilation step.  You can then make that plugin available for others to use on their own projects if you wish.</p>
<h2 id="what-else-can-it-do-">What else can it do?</h2>
<p>One feature that the PostCSS team has been keen to highlight is that you can start writing CSS with respect to new specifications right now by using plugins like <a href="https://github.com/cssnext/cssnext">cssnext</a>.</p>
<p>However, much like <a href="http://benfrain.com/breaking-up-with-sass-postcss/">Ben mentioned in his article</a> and similarly <a href="https://css-tricks.com/the-trouble-with-preprocessing-based-on-future-specs/">Chris Coyier went into in some depth recently</a>, I’m not convinced that people should be developing with this in mind.  Specifications can change many times before they become implemented and so there seems little value in learning to write CSS with respect to these until they become more stable.</p>
<hr>
<h2 id="how-fast-is-it-">How fast is it?</h2>
<p>If speed of compilation floats your boat, PostCSS is also incredibly fast – <a href="https://github.com/postcss/postcss/issues/64">apparently around 3x faster than libsass and 4x faster than Less</a>.  Whether that speed is noticeable in your build process probably comes down to the amount of CSS you’re working with; I’d imagine for most users the difference in speed would be barely noticeable (as we’re talking hundredths of milliseconds).</p>
<hr>
<h2 id="ease-of-setup">Ease of setup</h2>
<p>If you’re used to setting up Grunt or Gulp tasks, getting to grips with PostCSS will be a breeze.</p>
<p>The only trickery can come when specifying the order that your PostCSS plugins run in.  Some plugins are required to run before others will work as intended – such as transforming and applying CSS variables before being able to run conditional plugin transformations that involve variables.  This is an obvious case, but others take a little more thinking about.</p>
<p>On the whole though, setup was a relatively painless experience.</p>
<hr>
<h2 id="can-i-convert-my-project-from-sass-less-stylus-into-postcss-">Can I convert my project from Sass/Less/Stylus into PostCSS?</h2>
<p>PostCSS isn’t designed to replace your current preprocessor like-for-like; It’s designed so that you can extend the functionality of standard CSS.  Although it has plugins that can replicate other preprocessor features, trying to directly convert can be a painful experience.</p>
<p>Not all features of your current preprocessor will be replicated by PostCSS plugins and so if looking to make the switch, it’s important to research into what functionality you still require.</p>
<p>With the upcoming release of version 4.2 of PostCSS, you will be able to specify custom parsers, such as being able to parse SCSS.  This will likely help when being able to move projects over to PostCSS – as it should open up more possibilities for future plugins – but you will still need to make some adjustments to your projects.</p>
<hr>
<h2 id="plugin-support">Plugin Support</h2>
<p>A tool like PostCSS is only as good as the quality of it’s plugins, so how does it fair in this regard?</p>
<p>Well for a tool that’s still relatively young, it’s pretty good.  A full list of plugins can be found on the <a href="https://github.com/postcss/postcss#plugins">PostCSS Github Repo</a>.</p>
<h3 id="sass-type-features">Sass-type features</h3>
<p>As a current user of Sass, I wanted to make sure that there were plugins that could provide the functionality I couldn’t bear to be without.</p>
<p><em>Variables</em> are one of the pillars of writing maintainable CSS and the <a href="https://github.com/postcss/postcss-simple-vars">postcss-simple-vars</a> plugin let’s you use them in almost the exact same way as you would do in Sass.</p>
<p><em>Nesting</em> – via <a href="https://github.com/postcss/postcss-nested">postcss-nested</a> – is also easy to add, and conditional functionality, like <code>@if</code>, can be taken care of using the <a href="https://github.com/andyjansson/postcss-conditionals">postcss-conditionals</a> plugin.</p>
<p>Importing files using the <a href="https://github.com/postcss/postcss-import">postcss-imports</a> plugin is also possible, but is slightly less slick, defining partials in full, such as:</p>
<pre>
<code class="language-scss">@imports '_variables.css';</code>
</pre>

<p>Using  <em>mixins</em> is slightly more hit and miss.  Currently, the only plugin available – <a href="https://github.com/postcss/postcss-mixins">postcss-mixins</a> – gives you a less-than intuitive syntax to work with – to me anyway, you can decide for yourself:</p>
<pre>
<code class="language-scss">@define-mixin icon $name {
    padding-left: 16px;
    &::after {
        content: "";
        background-url: url(/icons/$(name).png);
    }
}

.search {
    @mixin icon search;
}</code>
</pre>

<p>To me, it would have made more sense to have followed a more familiar convention to those used in other preprocessors – using brackets to separate out the arguments of each mixin.  I could author my own plugin to do this I’m sure, but it’s disappointing to have to do this for such a key feature many developers will want to utilise.</p>
<p>Less important to me personally are Sass features like <code>@each</code>, <code>@for</code> and <code>@extend</code>, but plugins for those are all present too via <a href="https://github.com/outpunk/postcss-each">postcss-each</a>, <a href="https://github.com/antyakushev/postcss-for">postcss-for</a> and <a href="https://github.com/davidtheclark/postcss-simple-extend">postcss-simple-extend</a>.</p>
<h3 id="things-sass-can-t-do">Things Sass can’t do</h3>
<p>So what PostCSS plugins are currently available that give you features that preprocessors like Sass can’t?</p>
<p><a href="https://github.com/postcss/autoprefixer">Autoprefixr</a> is probably the most widely known PostCSS plugin and is a tool that I think every developer should be leveraging.  It let’s you write your CSS unprefixed – such as <code>transition: 250ms ease-in;</code> – along with defining the browsers you intend on supporting.  It then adds the necessary prefixes upon compilation.  This helps keep your CSS clean of prefixes and makes fallbacks more maintainable and less susceptible to redundancy.</p>
<p>Another useful plugin is <a href="https://github.com/hail2u/node-css-mqpacker"><code>css-mqpacker</code></a> which joins together multiple matching media query declarations into a single statement; a massively useful optimisation.</p>
<p>There are a <a href="https://github.com/postcss/postcss#plugins">whole host of plugins</a> with unique features that you may want to leverage and I expect this list to grow quite quickly as the uptake of PostCSS gathers pace.</p>
<h3 id="is-writing-your-own-plugin-easy-">Is writing your own plugin easy?</h3>
<p>Yes, but some edge cases aren’t possible (yet).</p>
<p>There are some excellent docs on <a href="https://github.com/postcss/postcss#how-to-develop-a-postcss-plugin">writing your own PostCSS plugin</a>, along with associated <a href="https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md">guidelines</a> and a <a href="https://github.com/postcss/postcss-plugin-boilerplate">boilerplate</a>.</p>
<p>So I went ahead and tried to write my own.</p>
<p>Single line code commenting is a small but important feature that Sass gives me, letting you comment code that doesn’t get compiled into your CSS, such as:</p>
<pre>
<code class="language-scss">// standard button class
.btn { … }</code>
</pre>

<p>Obviously in plain old CSS, this isn’t possible.  Comments are instead written:</p>
<pre>
<code class="language-scss">/* standard button class */
.btn { … }</code>
</pre>

<p>PostCSS has a plugin that helps give you similar functionality – <a href="https://github.com/ben-eb/postcss-discard-comments">postcss-discard-comments</a> – but I wanted to replicate the Sass-style syntax, as I find it slightly more flexible.</p>
<p>However, I hit a bit of a roadblock. <code>// my comment</code> is invalid CSS code and so when running the PostCSS parser over it, it fails due to the<code>/</code> character being invalid.  As a result, my plugin never got to transform the code as I wanted, as it never got that far.</p>
<p>This situation will shortly be resolved by being able to specify a <a href="https://github.com/postcss/postcss/issues/140">custom parser</a> – something that is due with the release of PostCSS v4.2.</p>
<hr>
<h2 id="considerations">Considerations</h2>
<p>As much as there is to like about the freedom PostCSS gives you, there are a couple of small cracks that need filling in before I think it will gain widespread support.</p>
<h3 id="plugin-search">Plugin Search</h3>
<p>For a tool that is based solely on the strength of it’s plugins, it’s going to need to make finding and discovering the most useful plugins easier than simply looking through a list on it’s repository.</p>
<p>In this way it shares characteristics to Sublime Text, which goes to great lengths to make this process easier through it’s <a href="https://packagecontrol.io/">package control website</a>.  Similarly, <a href="https://plugins.jquery.com/">jQuery plugins</a> are made more accessible through it’s plugin repository.</p>
<p>Without a similar solution, it’ll become increasingly difficult to find plugins that genuinely offer key functionality.  There are already upwards of 100 plugins listed on the PostCSS repository.  Realistically, most developers aren’t going to trawl through that list to find the diamonds in the rough that apply for their project.</p>
<h3 id="parsing-custom-syntax">Parsing Custom Syntax</h3>
<p>As mentioned in the section above on writing custom plugins, currently it’s not possible to parse, and therefore transform, syntax that isn’t 100% valid CSS.</p>
<p>This issue is currently being worked on by the PostCSS team and, as of the upcoming v4.2, you will be able to specify custom parsers which will resolve this issue. This will open up the ability to be able to parse SCSS syntax making PostCSS a lot more flexible.</p>
<h3 id="shortcuts">Shortcuts</h3>
<p>This isn’t so much a gripe with PostCSS, or something that will stop its growth, but it is an issue that PostCSS facilitates simply by giving developers so much freedom when transforming CSS in any way they like.</p>
<p>Writing plugins to transform your own shortcut syntax is a <em>terrible</em> idea on many levels.  For example, the <a href="https://github.com/davidhemphill/postcss-verthorz">postcss-verthorz</a> plugin let’s you write the following:</p>
<pre>
<code class="language-scss">.foo {
    padding-vert: 2rem;
    margin-horz: auto;
}

.bar {
    ph: 30px;
    mv: 100px;
}

// converts to
.foo {
    padding-top: 2rem;
    padding-bottom: 2rem;
    margin-left: auto;
    margin-right: auto;
}

.bar {
    padding-left: 30px;
    padding-right: 30px;
    margin-top: 100px;
    margin-bottom: 100px;
}</code>
</pre>

<p>The problem with this, and other plugins like <a href="https://github.com/seaneking/postcss-position">postcss-position</a>, is that it is complicating what should be uncomplicated – standard CSS definitions.  They are creating as much of a problem as they are solving.</p>
<p>Shortcuts like this should be utilised in text editors, not hard-coded ready to confuse future developers that work on the project.</p>
<p>I would hope that developers choose not to use PostCSS plugins to transform their CSS in this way, as it ultimately just fragments standard syntax more than is necessary.  But it does highlight the danger in giving people so much freedom – people can use that freedom to create things that arguably make their CSS less maintainable, rather than more so.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>PostCSS has absolutely amazing potential.</p>
<p>It truly offers a different way of thinking about processing CSS – one that many developers will embrace as an alternative to what is currently available.</p>
<p>Having the power to customise the way in which you can transform your CSS by being able to choose the plugins that you use is really empowering. It means you can introduce new features to your team at a speed you’re all comfortable with, rather than throwing a whole treasure chest of features into the mix and seeing what happens.</p>
<p>As should be remembered when adopting any new tool however, there are going to be some edge cases that need to be ironed out.  Ensure you thoroughly research whether PostCSS will give you all of the things you need it to before deciding on whether it is ready to use in your workflow.</p>
<p>At JUST EAT, we’ve added PostCSS to our workflow, but currently only to provide additional functionality that Sass can’t, such as Autoprefixer.  I envisage that we will gradually shift over to using PostCSS as the ability to write more flexible plugins that can transform parsed SCSS files becomes available.  For our team it makes sense to keep a syntax that the majority of our developers feel comfortable writing – at least until PostCSS has become slightly more mature.</p>
<p>But that doesn’t mean PostCSS isn’t right for your team or project – I would fully encourage you to take a look yourself at what PostCSS can offer you.  If PostCSS continues to develop and improve at the rate it is right now, it’s likely to be a part of many front-end developers workflows in the near future.</p>






			<p class="post-date separator-top">Posted on the 17th July 2015</p>

			

			<div id="disqus_thread" class="comments separator-top"></div>

		</section>

		<footer class="page-footer border-grey-white-top">
	<!-- Social links -->
<nav class="links-social">
	<ul>
		<li class="links-social-item links-social-email"><a href="mailto:hello@ashleynolan.co.uk" title="Email Me" rel="external" target="_blank"><span class="links-social-icon icon-email-shaded"></span><span class="screen-reader-text">Email</span></a></li>
		<li class="links-social-item links-social-twitter"><a href="http://twitter.com/AshNolan_" title="Find me on Twitter" rel="external" target="_blank"><span class="links-social-icon icon-twitter"></span><span class="screen-reader-text">Twitter</span></a></li>
		<li class="links-social-item links-social-linkedin"><a href="http://uk.linkedin.com/pub/ashley-nolan/16/980/684" title="My LinkedIn Profile" rel="external" target="_blank"><span class="links-social-icon icon-linkedin"></span><span class="screen-reader-text">LinkedIn</span></a></li>
	</ul>
</nav>


	 <div class="footer-content">
		 <p>I'm Ashley Nolan, a Senior UI Engineer at JUST EAT.  Do take a look around, or contact me in any of the usual ways – it'd be great to hear from you.</p>
	</div>
</footer>

	</div>

<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'ashleynolan'; // required: replace example with your forum shortname

(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-20668207-1', 'auto');
	  ga('send', 'pageview');
	</script>
</body>
</html>

